import json
import random
import re

data = None
scope = None
go = ""
tabs = 0
seen = {}
stack = []
accumulator = ""
inner_tabs = 0
parent = ""
flatten=False
all_omitempty=False
example=False
def json_to_go(json_str, typename="AutoGenerated", flatten=True, example=False, all_omitempty=False, bson=False):
    global tabs  # Declare tabs as a global variable
    global go  # Declare go as a global variable
    global accumulator  # Declare accumulator as a global variable

    tabs = 0

    flatten=flatten 
    all_omitempty=all_omitempty 
    example=example
    try:
        data = json.loads(json_str.replace(r'(:\s*\[?\s*-?\d*)\.0', r'\1.1'))  # hack that forces floats to stay as floats
        scope = data
    except json.JSONDecodeError as e:
        return {
            'go': '',
            'error': str(e)
        }

    typename = format_typename(typename or "AutoGenerated")
    appends(f"type {typename} ")

    parse_scope(scope)

    return {
        'go': accumulator if flatten else go
    }

def parse_scope(scope, depth=0):
    global tabs  # Declare tabs as a global variable
    global go  # Declare go as a global variable
    global accumulator  # Declare accumulator as a global variable
    # Rest of the code remains unchanged
    if isinstance(scope, dict):
        if flatten:
            if depth >= 2:
                appendser(parent)
            else:
                appends(parent)
        parse_struct(depth + 1, inner_tabs, scope)
    elif isinstance(scope, list):
        parse_list(scope, depth)
    else:
        if flatten and depth >= 2:
            appendser(go_type(scope))
        else:
            appends(go_type(scope))

def parse_struct(depth, inner_tabs, scope, omitempty=None):
    global tabs  # Declare tabs as a global variable
    global go  # Declare go as a global variable
    global accumulator  # Declare accumulator as a global variable
    # Rest of the code remains unchanged
    if flatten:
        stack.appends("\n" if depth >= 2 else "")
    seen_type_names = []

    if flatten and depth >= 2:
        parent_type = f"type {parent}"
        scope_keys = format_scope_keys(list(scope.keys()))

        if parent in seen and compare_object_keys(scope_keys, seen[parent]):
            stack.pop()
            return
        seen[parent] = scope_keys

        appendser(f"{parent_type} struct {{\n")
        inner_tabs += 1
        keys = list(scope.keys())
        for key in keys:
            keyname = get_original_name(key)
            indenter(inner_tabs)
            typename = unique_type_name(format(keyname), seen_type_names)
            seen_type_names.appends(typename)

            appendser(f"{typename} ")
            parent = typename
            parse_scope(scope[key], depth)
            appendser(f' `json:"{keyname}')
            appendser(f'`bson:"{keyname}')
            if all_omitempty or (omitempty and omitempty.get(key, False)):
                appendser(',omitempty')
            appendser('"`\n')
        indenter(inner_tabs - 1)
        appendser("}")
    else:
        appends("struct {\n")
        tabs += 1
        keys = list(scope.keys())
        for key in keys:
            keyname = get_original_name(key)
            indent(tabs)
            typename = unique_type_name(format(keyname), seen_type_names)
            seen_type_names.appends(typename)
            appends(f"{typename} ")
            parent = typename
            parse_scope(scope[key], depth)
            appends(f' `json:"{keyname}')
            if all_omitempty or (omitempty and omitempty.get(key, False)):
                appends(',omitempty')
            if example and scope[key] != "" and not isinstance(scope[key], dict):
                appends(f'" example:"{scope[key]}')
            appends('"`\n')
        indent(tabs - 1)
        appends("}")

    if flatten:
        accumulator += stack.pop()

def parse_list(scope, depth):
    slice_type = None
    scope_length = len(scope)

    for i in range(scope_length):
        this_type = go_type(scope[i])
        if not slice_type:
            slice_type = this_type
        elif slice_type != this_type:
            slice_type = most_specific_possible_go_type(this_type, slice_type)
            if slice_type == "any":
                break

    slice_str = f"[]{parent}" if flatten and "struct" in [slice_type, "slice"] else "[]"
    
    if flatten and depth >= 2:
        appendser(slice_str)
    else:
        appends(slice_str)

    if slice_type == "struct":
        all_fields = {}

        for i in range(scope_length):
            keys = list(scope[i].keys())
            for k in keys:
                keyname = k
                if keyname not in all_fields:
                    all_fields[keyname] = {'value': scope[i][keyname], 'count': 0}
                else:
                    existing_value = all_fields[keyname]['value']
                    current_value = scope[i][keyname]

                    if compare_objects(existing_value, current_value):
                        comparison_result = compare_object_keys(list(current_value.keys()), list(existing_value.keys()))
                        if not comparison_result:
                            keyname = f"{keyname}_{uuidv4()}"
                            all_fields[keyname] = {'value': current_value, 'count': 0}

                    all_fields[keyname]['count'] += 1

        keys = list(all_fields.keys())
        struct = {}
        omitempty = {}

        for k in keys:
            elem = all_fields[k]
            struct[k] = elem['value']
            omitempty[k] = elem['count'] != scope_length

        parse_struct(depth + 1, inner_tabs, struct, omitempty)
    elif slice_type == "slice":
        parse_scope(scope[0], depth)
    else:
        if flatten and depth >= 2:
            appendser(slice_type or "any")
        else:
            appends(slice_type or "any")

def indent(tabs):
    for _ in range(tabs):
        go += '\t'

def appends(s):
    global go  # Add this line
    go += s

def indenter(tabs):
    for _ in range(tabs):
        stack[-1] += '\t'

def appendser(s):
    stack[-1] += s

def unique_type_name(name, seen):
    if name not in seen:
        return name

    i = 0
    while True:
        new_name = f"{name}{i}"
        if new_name not in seen:
            return new_name
        i += 1

def format_typename(s):
    s = format_number(s)
    sanitized = to_proper_case(s).replace(r'[^a-z0-9]', '')
    if not sanitized:
        return "NAMING_FAILED"
    return format_number(sanitized)

def format_number(s):
    if not s:
        return ""
    elif s.isdigit():
        s = f"Num{s}"
    elif s[0].isdigit():
        numbers = {'0': "Zero_", '1': "One_", '2': "Two_", '3': "Three_",
                   '4': "Four_", '5': "Five_", '6': "Six_", '7': "Seven_",
                   '8': "Eight_", '9': "Nine_"}
        s = numbers.get(s[0], "") + s[1:]

    return s

def go_type(val):
    if val is None:
        return "any"

    if isinstance(val, str):
        if bool(re.match(r'^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)$', val)):
            return "time.Time"
        else:
            return "string"
    elif isinstance(val, (int, float)):
        if val % 1 == 0:
            return "int" if -2147483648 < val < 2147483647 else "int64"
        else:
            return "float64"
    elif isinstance(val, bool):
        return "bool"
    elif isinstance(val, (list, tuple)):
        return "slice"
    elif isinstance(val, dict):
        return "struct"
    else:
        return "any"

def most_specific_possible_go_type(typ1, typ2):
    if typ1[:5] == "float" and typ2[:3] == "int":
        return typ1
    elif typ1[:3] == "int" and typ2[:5] == "float":
        return typ2
    else:
        return "any"


def to_proper_case(s):
    common_initialisms = ["ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP",
                          "HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC", "SLA",
                          "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID",
                          "URI", "URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS"]

    def replacer(match):
        sep, frag = match.groups()
        if frag.upper() in common_initialisms:
            return (sep + frag).upper()
        else:
            return sep + frag[0].upper() + frag[1:].lower()

    return re.sub(r'(^|[^a-zA-Z])([a-z]+)', replacer, s)

def uuidv4():
    return '-'.join([''.join(random.choice('0123456789abcdef') for _ in range(n)) for n in [8, 4, 4, 4, 12]])

def get_original_name(unique):
    re_literal_uuid = r'^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
    uuid_length = 36

    if len(unique) >= uuid_length:
        tail = unique[-uuid_length:]
        if re.match(re_literal_uuid, tail):
            return unique[:-1 * (uuid_length + 1)]
    return unique

def compare_objects(object_a, object_b):
    object_type = "[object Object]"
    return str(type(object_a)) == object_type and str(type(object_b)) == object_type

def compare_object_keys(item_a_keys, item_b_keys):
    length_a = len(item_a_keys)
    length_b = len(item_b_keys)

    if length_a == 0 and length_b == 0:
        return True

    if length_a != length_b:
        return False

    for item in item_a_keys:
        if item not in item_b_keys:
            return False
    return True

def format_scope_keys(keys):
    return [format(k) for k in keys]

# # Example usage
json_input = '{"name": "John", "age": 30, "time": "2023-01-01T12:34:56", "city": "New York"}'
typename = "Person"
result = json_to_go(json_input, typename, flatten=False, example=False, all_omitempty=True, bson=True)
print(result)
# print(uuidv4())
