import json
import re
import random
from datetime import datetime

class JSONToGoConverter:
    def __init__(self, json_str, typename="AutoGenerated", flatten=True, example=False, all_omitempty=False, bson=False):
        self.data = json.loads(json_str.replace(r'(:\s*\[?\s*-?\d*)\.0', r'\1.1'))
        self.scope = self.data
        self.go = ""
        self.tabs = 0
        self.seen = {}
        self.stack = []
        self.accumulator = ""
        self.inner_tabs = 0
        self.parent = ""
        self.typename = self.format(typename or "AutoGenerated")
        self.flatten = flatten
        self.example = example
        self.all_omitempty = all_omitempty
        self.bson = bson

    def convert(self):
        self.append(f"type {self.typename} ")
        self.parse_scope(self.scope)
        return self.go

    def parse_scope(self, scope, depth=0):
        if isinstance(scope, dict):
            self.parse_struct(depth + 1, self.inner_tabs, scope)
        elif isinstance(scope, list):
            slice_type = None
            for item in scope:
                this_type = self.go_type(item)
                if not slice_type:
                    slice_type = this_type
                elif slice_type != this_type:
                    slice_type = self.most_specific_possible_go_type(this_type, slice_type)
                    if slice_type == "any":
                        break

            slice_str = f"[]"
            if self.flatten and depth >= 2:
                self.appender(slice_str)
            else:
                self.append(slice_str)

            if slice_type == "struct":
                all_fields = {}
                for item in scope:
                    for key, value in item.items():
                        if key not in all_fields:
                            all_fields[key] = {"value": value, "count": 0}
                        else:
                            existing_value = all_fields[key]["value"]
                            current_value = value
                            if self.compare_objects(existing_value, current_value):
                                comparison_result = self.compare_object_keys(
                                    list(current_value.keys()),
                                    list(existing_value.keys())
                                )
                                if not comparison_result:
                                    key = f"{key}_{self.uuidv4()}"
                                    all_fields[key] = {"value": current_value, "count": 0}
                            all_fields[key]["count"] += 1

                struct_keys = list(all_fields.keys())
                struct = {}
                omitempty = {}
                for key in struct_keys:
                    elem = all_fields[key]
                    struct[key] = elem["value"]
                    omitempty[key] = elem["count"] != len(scope)

                self.parse_struct(depth + 1, self.inner_tabs, struct, omitempty)
            elif slice_type == "slice":
                self.parse_scope(scope[0], depth)
            else:
                if self.flatten and depth >= 2:
                    self.appender(slice_type or "any")
                else:
                    self.append(slice_type or "any")
        else:
            if self.flatten and depth >= 2:
                self.appender(self.go_type(scope))
            else:
                self.append(self.go_type(scope))

    def parse_struct(self, depth, inner_tabs, scope, omitempty=None):
        if self.flatten:
            self.stack.append("\n" if depth >= 2 else "")
        seen_type_names = []
        if self.flatten and depth >= 2:
            parent_type = f"type {self.parent}"
            scope_keys = self.format_scope_keys(list(scope.keys()))
            if self.parent in self.seen and self.compare_object_keys(scope_keys, self.seen[self.parent]):
                self.stack.pop()
                return
            self.seen[self.parent] = scope_keys

            self.appender(f"{parent_type}")
            self.inner_tabs += 1
            keys = list(scope.keys())
            for key in keys:
                keyname = self.get_original_name(key)
                self.indenter(self.inner_tabs)
                typename = self.unique_type_name(self.format(keyname), seen_type_names)
                seen_type_names.append(typename)
                self.appender(f"{typename}")
                self.parent = typename
                self.parse_scope(scope[key], depth)
                self.appender('\n')

            self.indenter(self.inner_tabs - 1)
            self.appender("end")
        else:
            self.append("struct {\n")
            self.tabs += 1
            keys = list(scope.keys())
            for key in keys:
                keyname = self.get_original_name(key)
                self.indent(self.tabs)
                typename = self.unique_type_name(self.format(keyname), seen_type_names)
                seen_type_names.append(typename)
                self.append(f"{typename} ")
                self.parent = typename
                self.parse_scope(scope[key], depth)
                self.append('\n')

            self.indent(self.tabs - 1)
            self.append("}\n")

        if self.flatten:
            self.accumulator += self.stack.pop()

    def indent(self, tabs):
        self.append('\t' * tabs)

    def append(self, string):
        self.go += string

    def indenter(self, tabs):
        self.stack[-1] += '\t' * tabs

    def appender(self, string):
        self.stack[-1] += string

    def unique_type_name(self, name, seen):
        if name not in seen:
            return name

        i = 0
        while True:
            new_name = f"{name}{i}"
            if new_name not in seen:
                return new_name
            i += 1

    def format(self, string):
        string = self.format_number(string)

        sanitized = self.to_proper_case(string).replace(r'[^a-z0-9]', "")
        if not sanitized:
            return "NAMING_FAILED"

        return self.format_number(sanitized)

    def format_number(self, string):
        if not string:
            return ""
        elif string.isdigit():
            string = f"Num{string}"
        elif string[0].isdigit():
            numbers = {'0': "Zero_", '1': "One_", '2': "Two_", '3': "Three_",
                       '4': "Four_", '5': "Five_", '6': "Six_", '7': "Seven_",
                       '8': "Eight_", '9': "Nine_"}
            string = numbers[string[0]] + string[1:]

        return string

    def go_type(self, val):
        if val is None:
            return "any"

        if isinstance(val, str):
            if self.is_datetime_string(val):
                return "time.Time"
            else:
                return "string"
        elif isinstance(val, (int, float)):
            if isinstance(val, int) and -2147483648 < val < 2147483647:
                return "int"
            else:
                return "int64" if isinstance(val, int) else "float64"
        elif isinstance(val, bool):
            return "bool"
        elif isinstance(val, list):
            return "[]interface{}"
        elif isinstance(val, dict):
            return "map[]"
        else:
            return "any"

    def most_specific_possible_go_type(self, typ1, typ2):
        if typ1[:5] == "float" and typ2[:3] == "int":
            return typ1
        elif typ1[:3] == "int" and typ2[:5] == "float":
            return typ2
        else:
            return "any"

    def to_proper_case(self, string):
        common_initialisms = [
            "ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP",
            "HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC", "SLA",
            "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID",
            "URI", "URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS"
        ]

        if re.match(r'^[_A-Z0-9]+$', string):
            string = string.lower()

        return re.sub(r'(^|[^a-zA-Z])([a-z]+)', lambda m: (m.group(1) + m.group(2).upper()), string)

    def uuidv4(self):
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(r'[xy]', lambda c: (str(hex(int(c, 16) & 0xf))[2:] if c == 'x' else str(hex(int(c, 16) & 0x3 | 0x8))[2:]))

    def get_original_name(self, unique):
        re_literal_uuid = r'^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
        uuid_length = 36

        if len(unique) >= uuid_length:
            tail = unique[-uuid_length:]
            if re.match(re_literal_uuid, tail):
                return unique[:-1 * (uuid_length + 1)]
        return unique

    def compare_objects(self, object_a, object_b):
        return isinstance(object_a, dict) and isinstance(object_b, dict)

    def compare_object_keys(self, item_a_keys, item_b_keys):
        length_a = len(item_a_keys)
        length_b = len(item_b_keys)

        if length_a == 0 and length_b == 0:
            return True

        if length_a != length_b:
            return False

        for item in item_a_keys:
            if item not in item_b_keys:
                return False

        return True

    def format_scope_keys(self, keys):
        for i in range(len(keys)):
            keys[i] = self.format(keys[i])
        return keys

    def is_datetime_string(self, string):
        try:
            datetime.fromisoformat(string)
            return True
        except ValueError:
            return False


# Example Usage
json_input = '{"name": "John", "age": 30, "time": "2023-01-01T12:34:56", "city": "New York"}'
typename = "Person"
converter = JSONToGoConverter(json_input, typename, flatten=False, example=False, all_omitempty=True, bson=True)
result = converter.convert()
print(result)
